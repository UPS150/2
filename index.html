<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Three.js Dynamic Viewports with Drifting Car-like Cubes</title>
    <style>
      body { margin: 0; }
      canvas { display: block; }
      /* Add CSS for the overlay */
      #ui-overlay {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-family: Arial, sans-serif;
        font-size: 14px;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
      }
      #sliders {
        position: absolute;
        bottom: 10px;
        left: 10px;
        color: rgb(0, 0, 0);
        font-family: Arial, sans-serif;
        font-size: 14px;
        background: rgba(255, 255, 255, 0.7);
        padding: 10px;
        border-radius: 5px;
      }
      input[type="range"] {
        width: 150px;
      }
    </style>
  </head>
  <body>
    <!-- Add HTML for UI overlay -->
    <div id="ui-overlay">
      <div id="fps">FPS: 0</div>
      <div id="speeds">Speeds: </div>
      <div id="camera">Camera: 1.0</div>
      <div id="friction">Friction: 1.000</div>
    </div>
    <div id="sliders">
      <label for="friction-slider">Friction (0.9-1.0):</label>
      <input type="range" id="friction-slider" min="0.9" max="1.0" step="0.001" value="1.0">
      <br>      
      <label for="camera-distance">Camera Distance (1-49):</label>
      <input type="range" id="camera-distance" min="1" max="49" step="0.1" value="1">
      <br>
      <label for="speed-slider">Max Speed (0.1-1.0):</label>
      <input type="range" id="speed-slider" min="0.1" max="1.0" step="0.01" value="0.5">
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

      // Scene setup
      const scene = new THREE.Scene();

      // Load HDRI (sky with clouds) from the same folder as the HTML file
      const rgbeLoader = new RGBELoader();
      rgbeLoader.load(
        './cloudy_sunset_1k.hdr',
        (texture) => {
          texture.mapping = THREE.EquirectangularReflectionMapping;
          scene.environment = texture; // Use HDRI for lighting and reflections
          scene.background = texture; // Use HDRI as background (sky with clouds)
        },
        undefined,
        (error) => {
          console.error('Error loading HDRI:', error);
        }
      );

      // Add directional light
      const light = new THREE.DirectionalLight(0xffffff, 0.5); // Reduced intensity to balance with HDRI
      light.position.set(1, 1, 1);
      scene.add(light);

      // Add a circular racing track (annular plane)
      const trackInnerRadius = 100;
      const trackOuterRadius = 115;
      const trackGeometry = new THREE.RingGeometry(trackInnerRadius, trackOuterRadius, 64, 1);
      const trackMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x333333, 
        side: THREE.DoubleSide,
        roughness: 0.7, // Less reflective for track
        metalness: 0.1 
      });
      const track = new THREE.Mesh(trackGeometry, trackMaterial);
      track.rotation.x = -Math.PI / 2;
      track.position.y = 0;
      scene.add(track);

      // Add a straight rectangular strip across the center
      const stripWidth = 2 * trackInnerRadius;
      const stripHeight = trackOuterRadius - trackInnerRadius;
      const stripGeometry = new THREE.PlaneGeometry(stripWidth, stripHeight);
      const strip = new THREE.Mesh(stripGeometry, trackMaterial);
      strip.rotation.x = -Math.PI / 2;
      strip.position.y = 0;
      scene.add(strip);

      // Create four cubes (cars) with different colors and physics properties
      const geometry = new THREE.BoxGeometry(1, 0.5, 2);
      const cubes = [
        { mesh: new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.2, metalness: 0.5 })), velocity: new THREE.Vector3(), angle: 0 },
        { mesh: new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0x00ff00, roughness: 0.2, metalness: 0.5 })), velocity: new THREE.Vector3(), angle: 0 },
        { mesh: new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0x0000ff, roughness: 0.2, metalness: 0.5 })), velocity: new THREE.Vector3(), angle: 0 },
        { mesh: new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.2, metalness: 0.5 })), velocity: new THREE.Vector3(), angle: 0 }
      ];

      // Spawn cubes on the track
      cubes.forEach((cube, index) => {
        const theta = (index * Math.PI) / 2;
        const radius = (trackInnerRadius + trackOuterRadius) / 2;
        cube.mesh.position.set(radius * Math.cos(theta), 0.25, radius * Math.sin(theta));
        cube.angle = theta + Math.PI / 2;
        cube.mesh.rotation.y = cube.angle;
        scene.add(cube.mesh);
      });

      // Renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Camera definitions
      const cameraDefinitions = [
        { type: 'Perspective', camera: new THREE.PerspectiveCamera(75, 1, 0.1, 1000), offset: new THREE.Vector3(0, 2, 5), controls: ['w', 'a', 's', 'd'] },
        { type: 'Perspective', camera: new THREE.PerspectiveCamera(75, 1, 0.1, 1000), offset: new THREE.Vector3(0, 2, 5), controls: ['ArrowUp', 'ArrowLeft', 'ArrowDown', 'ArrowRight'] },
        { type: 'Perspective', camera: new THREE.PerspectiveCamera(75, 1, 0.1, 1000), offset: new THREE.Vector3(0, 2, 5), controls: ['5', '1', '2', '3'] },
        { type: 'Perspective', camera: new THREE.PerspectiveCamera(75, 1, 0.1, 1000), offset: new THREE.Vector3(0, 2, 5), controls: ['i', 'j', 'k', 'l'] }
      ];

      // Dynamic viewports
      let activeViewports = [{ x: 0, y: 0, width: 1, height: 1, cameraIndex: 0, cubeIndex: 0 }];
      const cameras = cameraDefinitions.map(def => {
        def.camera.position.copy(def.offset);
        def.camera.lookAt(0, 0, 0);
        return def.camera;
      });
      const controls = cameras.map(camera => {
        const control = new OrbitControls(camera, renderer.domElement);
        control.enableDamping = true;
        control.dampingFactor = 0.05;
        control.screenSpacePanning = false;
        control.minDistance = 1;
        control.maxDistance = 50;
        return control;
      });

      // Update viewport layout
      function updateViewports() {
        const count = activeViewports.length;
        activeViewports = [];
        if (count === 1) {
          activeViewports.push({ x: 0, y: 0, width: 1, height: 1, cameraIndex: 0, cubeIndex: 0 });
        } else if (count === 2) {
          activeViewports.push({ x: 0, y: 0, width: 0.5, height: 1, cameraIndex: 0, cubeIndex: 0 });
          activeViewports.push({ x: 0.5, y: 0, width: 0.5, height: 1, cameraIndex: 1, cubeIndex: 1 });
        } else if (count === 3) {
          activeViewports.push({ x: 0, y: 0.5, width: 0.5, height: 0.5, cameraIndex: 0, cubeIndex: 0 });
          activeViewports.push({ x: 0.5, y: 0.5, width: 0.5, height: 0.5, cameraIndex: 1, cubeIndex: 1 });
          activeViewports.push({ x: 0, y: 0, width: 0.5, height: 0.5, cameraIndex: 2, cubeIndex: 2 });
        } else if (count === 4) {
          activeViewports.push({ x: 0, y: 0.5, width: 0.5, height: 0.5, cameraIndex: 0, cubeIndex: 0 });
          activeViewports.push({ x: 0.5, y: 0.5, width: 0.5, height: 0.5, cameraIndex: 1, cubeIndex: 1 });
          activeViewports.push({ x: 0, y: 0, width: 0.5, height: 0.5, cameraIndex: 2, cubeIndex: 2 });
          activeViewports.push({ x: 0.5, y: 0, width: 0.5, height: 0.5, cameraIndex: 3, cubeIndex: 3 });
        }
      }

      // Keyboard controls
      const keyState = {};
      window.addEventListener('keydown', (event) => {
        keyState[event.key] = true;
      });
      window.addEventListener('keyup', (event) => {
        keyState[event.key] = false;
      });

      // Physics parameters
      let maxSpeed = 0.5;
      const acceleration = 0.02;
      let friction = 1;
      const turnSpeed = 0.05;

      // UI elements
      const fpsDisplay = document.getElementById('fps');
      const speedsDisplay = document.getElementById('speeds');
      const frictionDisplay = document.getElementById('friction');
      const cameraDisplay = document.getElementById('camera');
      const frictionSlider = document.getElementById('friction-slider');
      const speedSlider = document.getElementById('speed-slider');
      const cameraDistanceSlider = document.getElementById('camera-distance');

      // Slider event listeners
      frictionSlider.addEventListener('input', () => {
        friction = parseFloat(frictionSlider.value);
        frictionDisplay.textContent = `Friction: ${friction.toFixed(3)}`;
      });
      speedSlider.addEventListener('input', () => {
        maxSpeed = parseFloat(speedSlider.value);
      });
      cameraDistanceSlider.addEventListener('input', () => {
        const distance = parseFloat(cameraDistanceSlider.value);
        controls.forEach(control => {
          control.minDistance = distance;
        });
        cameraDisplay.textContent = `Camera: ${distance.toFixed(1)}`;
      });

      // Update cube positions with drifting physics
      function updateCubePositions(delta) {
        activeViewports.forEach((viewport) => {
          const cube = cubes[viewport.cubeIndex];
          const cameraDef = cameraDefinitions[viewport.cameraIndex];
          const [forward, left, backward, right] = cameraDef.controls;

          // Handle input
          let accelInput = 0;
          let turn = 0;
          if (keyState[forward]) accelInput += acceleration;
          if (keyState[backward]) accelInput -= acceleration;
          if (keyState[left]) turn += turnSpeed;
          if (keyState[right]) turn -= turnSpeed;

          // Update rotation
          cube.angle += turn;
          cube.mesh.rotation.y = cube.angle;

          // Apply acceleration in the direction the cube is facing
          const direction = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), cube.angle);
          cube.velocity.add(direction.multiplyScalar(accelInput * delta * 60));

          // Apply friction
          cube.velocity.multiplyScalar(friction);

          // Cap speed
          if (cube.velocity.length() > maxSpeed) {
            cube.velocity.setLength(maxSpeed);
          }

          // Update position based on velocity (allows drifting)
          cube.mesh.position.add(cube.velocity.clone().multiplyScalar(delta * 60));

          // Keep cube on plane
          cube.mesh.position.y = 0.25;

          // Constrain to track or straight strip
          const x = cube.mesh.position.x;
          const z = cube.mesh.position.z;
          const distanceFromCenter = Math.sqrt(x ** 2 + z ** 2);
          const stripHalfHeight = stripHeight / 2;

          // Check if cube is within the straight strip bounds
          const isInStrip = Math.abs(z) <= stripHalfHeight && Math.abs(x) <= trackInnerRadius;

          if (!isInStrip) {
            // Apply circular track constraints
            if (distanceFromCenter < trackInnerRadius || distanceFromCenter > trackOuterRadius) {
              const radialDirection = new THREE.Vector3(x, 0, z).normalize();
              const radialVelocity = cube.velocity.dot(radialDirection);
              if (
                (distanceFromCenter < trackInnerRadius && radialVelocity < 0) ||
                (distanceFromCenter > trackOuterRadius && radialVelocity > 0)
              ) {
                cube.velocity.sub(radialDirection.multiplyScalar(radialVelocity));
              }
              const correctionFactor = (trackInnerRadius + trackOuterRadius) / (2 * distanceFromCenter);
              cube.mesh.position.x *= correctionFactor;
              cube.mesh.position.z *= correctionFactor;
            }
          } else {
            // Constrain to strip boundaries (z-direction)
            if (Math.abs(z) > stripHalfHeight) {
              const zDirection = new THREE.Vector3(0, 0, Math.sign(z));
              const zVelocity = cube.velocity.dot(zDirection);
              if ((z > stripHalfHeight && zVelocity > 0) || (z < -stripHalfHeight && zVelocity < 0)) {
                cube.velocity.sub(zDirection.multiplyScalar(zVelocity));
              }
              cube.mesh.position.z = Math.max(-stripHalfHeight, Math.min(stripHalfHeight, z));
            }
          }

          // Update camera to follow cube
          const camera = cameras[viewport.cameraIndex];
          const offset = cameraDef.offset.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), cube.angle);
          camera.position.copy(cube.mesh.position).add(offset);
          camera.lookAt(cube.mesh.position);
          controls[viewport.cameraIndex].target.copy(cube.mesh.position);
        });
      }

      // Add/Remove viewports with +/-
      window.addEventListener('keydown', (event) => {
        if (event.key === '+') {
          if (activeViewports.length < 4) {
            activeViewports.push({ x: 0, y: 0, width: 0, height: 0, cameraIndex: activeViewports.length, cubeIndex: activeViewports.length });
            updateViewports();
          }
        } else if (event.key === '-') {
          if (activeViewports.length > 1) {
            activeViewports.pop();
            updateViewports();
          }
        }
      });

      // Animation loop with FPS calculation
      let lastTime = performance.now();
      let frameCount = 0;
      let fps = 0;
      let lastFpsUpdate = performance.now();
      function animate() {
        requestAnimationFrame(animate);
        const currentTime = performance.now();
        const delta = (currentTime - lastTime) / 1000;
        lastTime = currentTime;

        // Update FPS
        frameCount++;
        if (currentTime - lastFpsUpdate >= 1000) {
          fps = frameCount;
          frameCount = 0;
          lastFpsUpdate = currentTime;
          fpsDisplay.textContent = `FPS: ${fps}`;
        }

        // Update speeds display
        const speeds = activeViewports.map((viewport, i) => {
          const speed = cubes[viewport.cubeIndex].velocity.length() * 60;
          return `Car ${i + 1}: ${speed.toFixed(2)} u/s`;
        });
        speedsDisplay.textContent = `Speeds: ${speeds.join(', ')}`;

        // Update cube positions
        updateCubePositions(delta);

        // Update controls
        controls.forEach(control => control.update());

        // Render each viewport
        renderer.setScissorTest(true);
        activeViewports.forEach((viewport) => {
          const { x, y, width, height, cameraIndex } = viewport;
          const camera = cameras[cameraIndex];

          // Set viewport and scissor
          renderer.setViewport(x * renderer.domElement.width, y * renderer.domElement.height, width * renderer.domElement.width, height * renderer.domElement.height);
          renderer.setScissor(x * renderer.domElement.width, y * renderer.domElement.height, width * renderer.domElement.width, height * renderer.domElement.height);

          // Clear viewport
          renderer.clear();

          // Adjust camera aspect
          camera.aspect = (width * renderer.domElement.width) / (height * renderer.domElement.height) || 1;
          camera.updateProjectionMatrix();

          // Render
          renderer.render(scene, camera);
        });
        renderer.setScissorTest(false);
      }

      animate();

      // Handle window resize
      window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        animate();
      });
    </script>
  </body>
</html>